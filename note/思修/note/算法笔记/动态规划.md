# 动态规划

**能用动态规划解决的问题，需要满足三个条件：最优子结构，无后效性和子问题重叠。**



> - 最优子结构：具有最优子结构也可能是适合用贪心的方法求解。
> - 无后效性：已经求解的子问题，不会再受到后续决策的影响。
> - 子问题重叠：如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。



## 背包



### 01背包

**一个物体只有两种可能的状态（取与不取），对应二进制中的 0 和 1，这类问题便被称为「0-1 背包问题」。**

对于第i个物品， 其代价(重量、体积等)为w[i]，权重(一般为价值)为v[i]。

设$f_{i,j}$ 为：在放i个物品的情况下，容量为 j的背包所能达到的最大总价值。

> 考虑转移。假设当前已经处理好了前 i-1个物品的所有状态，那么对于第 i 个物品，当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为$f_{i,j}$；当其放入背包时，背包的剩余容量会减小 w[i]，背包中物品的总价值会增大 v[i]，故这种情况的最大价值为$f_{i-1,j-w[i]} + v[i]$ 	——oi wiki



那么就有`f[i][j]=max(f[i-1][j], f[i-1][j-w[i]]+v[i])`

观察上式不难发现：对`f[i]`有影响的只有`f[i-1]`，所以实际应用中为防止MLE，常使用滚动数组来优化。

最后就能得到最终的状态转移方程：

$f_{j} = max(f_j, f_{j-w_i}+v_i)$

核心代码：

```cpp
for (int i = 1; i <= n; ++i)
  for (int j = W; j >= w[i]; --j) 
      f[j] = max(f[j], f[j - w[i]] + v[i]);
```



***注意*** ：内层循环的顺序为W到w[i]，以避免`f[i-1][j-w[i]]`改变影响到`f[i][j]`。

实际上，内层循环从0开始时就相当于物品i可以被重复选择（那就是[完全背包](# 完全背包)了）。



### 完全背包

> 完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。  ——oi wiki



对于完全背包，其朴素做法的核心就在于对第i件物品的枚举。( O(n^3^) 的时间复杂度)

$f_{i,j} = max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)$

> 当我们转移时，$f_{i,j-w_i}$ 已经由 $f_{i,j-2\times w_i}$ 更新过，那么 $f_{i,j-w_i}$就是充分考虑了第 i件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。



那么优化后有：$f_{j} = max(f_j, f_{j-w_i}+v_i)$

代码：

```cpp
for (int i = 1; i <= n; ++i)
  for (int j = w[i]; j >=W ; ++j) 
      f[j] = max(f[j], f[j - w[i]] + v[i]);
```

***01背包和完全背包最核心的不同在于遍历顺序：***

- **01背包**：
  - 内层循环是 **逆向遍历**（从 `W` 到 `w[i]`）。
  - 原因：确保每个物品只被选择一次。如果正向遍历，可能会重复选择同一个物品。
- **完全背包**：
  - 内层循环是 **正向遍历**（从 `w[i]` 到 `W`）。
  - 原因：允许每个物品被多次选择。正向遍历会覆盖之前的状态，从而实现多次选择。