# 搜索

> 搜索，也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。
>
> 搜索有很多优化方式，如减小状态空间，更改搜索顺序，剪枝等。
>
> 搜索是一些高级算法的基础。在 OI 中，纯粹的搜索往往也是得到部分分的手段，但可以通过纯粹的搜索拿到满分的题目非常少。		——oi wiki



## DFS

> DFS 全称是 Depth First Search，中文名是深度优先搜索，是一种用于遍历或搜索树或图的算法。所谓深度优先，就是说每次都尝试向更深的节点走。

DFS可以利用递归或栈实现

**递归实现：**

```cpp
vector<vector<int>> adj;  // 邻接表
vector<bool> vis;         // 记录节点是否已经遍历

void dfs(const int u) {
  vis[u] = true;
  for (int v : adj[u])
    if (!vis[v]) dfs(v)
}
```

**栈实现：**

```cpp
vector<vector<int>> adj;  // 邻接表
vector<bool> vis;         // 记录节点是否已经遍历

void dfs(int s) {
  stack<int> st;
  st.push(s);
  vis[s] = true;

  while (!st.empty()) {
    int u = st.top();
    st.pop();

    for (int v : adj[u]) {
      if (!vis[v]) {
        vis[v] = true;  // 确保栈里没有重复元素
        st.push(v);
      }
    }
  }
}
```



## BFS

> BFS 全称是 Breadth First Search，中文名是宽度优先搜索，也叫广度优先搜索。
>
> 是图上最基础、最重要的搜索算法之一。
>
> 所谓宽度优先。就是每次都尝试访问同一层的节点。 如果同一层都访问完了，再访问下一层。
>
> 这样做的结果是，BFS 算法找到的路径是从起点开始的 **最短** 合法路径。换言之，这条路径所包含的边数最小。
>
> 在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。		——oi wiki



```cpp
void bfs(int x, int y){
	
	queue<pair<int, int>> qu;
	qu.push({x, y});
	
	while(!qu.empty()){
		auto cur = qu.front();
		qu.pop();
		
		for(int i=0 ; i<8 ; ++i){
			int tx = cur.first + dx[i];
			int ty = cur.second + dy[i];
			if(tx<1 || tx>n || ty<1 || ty>m) continue;
			if(!vis[tx][ty]){
				vis[tx][ty] = 1;
				map[tx][ty] = map[cur.first][cur.second]+1;
				qu.push({tx, ty});
			}
		}	
	}
	return; 
}
```

代码片段来自洛谷[P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)