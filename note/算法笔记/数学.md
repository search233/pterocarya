# 数学

## 序理论

> 序理论是利用二元关系来将「次序」这一概念严格化的数学分支		——oi wiki

### 二元关系

- 性质：
  1. 自反性
  2. 反自反性
  3. 对称性
  4. 反对称性
  5. 非对称性
  6. 传递性
  7. 连接性
  8. 两基性
  9. 不可比的传递性

### 偏序集



## 组合数学



### 排列数

记为$A(n, k)$，表示从n个不同元素中取出k个元素进行排列的数目。

基本公式：$A(n, k)=\frac{n!}{(n-k)!}$

```cpp
int A(int n, int k){
    return k ? A(n-1,k-1)*n : 1;
}
```

实际应用中如果结果需要取模， 那么可以在计算的过程中不断取模以减小数据量。



### 组合数

记为$C(n, k)$，表示从n个不同元素中取出k个元素的组合数，不考虑元素的顺序。

基本公式：$C(n, k)=\frac{n!}{k!\times (n-k)!}$

实际应用中会利用递推公式$C(n, k)=C(n-1, k-1) + C(n-1, k)$计算。

（该公式在n远小于k时尤其有效）

$k>\frac{n}{2}$时， 利用$C(n, k) = C(n, n-k)$化简。

```cpp
int C(int n, int k){
    return k ? C(n-1, k-1) + C(n-1, k) : 1;
}
```



## 质数(与合数)

### [定义](https://baike.baidu.com/item/质数#1)

> 一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数（规定1既不是质数也不是合数）。



### 性质

#### 基本性质

- 设a为大于1的正整数，若p是a的大于1的最小正约数则p必为质数。
- 如果 a 是合数，p 是 a 的最小约数，那么 $p \le\sqrt{a}$

#### 分布规律

- 若n为正整数，在n²到(n+1)² 之间至少有一个质数。

- 若n为大于或等于2的正整数，在n到n!之间至少有一个质数。

- 在一个大于1的数a和它的2倍之间（即区间(a, 2a]中）必存在至少一个素数


#### 素数分解（算数基本定理

* 任何大于1的整数都可以被分解成**若干个素数的幂的乘积**，且不计素因子的排列顺序时分解方法是==唯一==的。
* 把素因子从小到大排列，就得到了**标准素数分解式**。

> 例如：$720 = 2^4 \cdot 3^2 \cdot 5^1$



### 相关算法

#### 素数判断

```cpp
bool isprime(int x){
	if(x<=1) return false;
	for(int i=2;i<=sqrt(x);i++){
		if(x%i==0) return false;
	}
	return true;
}
```



#### 素数筛

- **埃氏筛法**

  该方法时间复杂度$O(nloglogn)$, 对于某些数字可能会被多次筛选

  > 例如一个数 24，它会被 2, 3, 4 三个数标记，这就重复了两次，更大的数同理。

```cpp
//生成不大于 n 的所有质数
bool numlist[100000001];
int prime[20000001], cnt;
void work(int n){
	for(int i=2; i<=n; i++){
		if(numlist[i]==false){
			prime[++cnt] = i ;
			for(int j=i*2; j<=n; j+=i)
				numlist[j] = true;
		}
	}
	return;
}
```



- **欧拉筛法**

  该方法时间复杂度$O(n)$， 利用了[素数的基本性质](# 基本性质)。
  简单来说：

  1. 对于一个合数n，可以表示为其最小质因数$fac_1$与最大的非自身因数$fac_2$的乘积。
  
     即： 有等式$n=fac_1\times fac_2$，$fac_1$与$fac_2$使得n唯一，从而避免重复筛选。
  
  2. 对于每一个$fac_2$，当其为合数时必然有一最小质因数$p$。
  
     1. $fac_2$被遍历到时，$p$已经在 `prime` 中
     2. 在标记$fac_2 \times p$后，`i%prime[j]==0`，退出内层循环。
  
  ```cpp
  bool vis[100000001];
  int prime[20000001], cnt = 0;
  void work(int n){
  	for(int i=2; i<=n; i++){
  		if(vis[i]==false)
  			prime[++cnt] = i ;
  		for(int j=1 ; j<=cnt && prime[j]<=n/i ; ++j){
  			vis[i*prime[j]] = true;
  			if(i%prime[j]==0)
  				break;
  		} 
  	}
  	return;
  }
  ```
  



在欧拉筛的过程中可以记录到每个数字的最小质数：

```cpp
int prime[N];
int cnt = 0, minp[N];
bool vis[N];
minp[1] = 1;

for (int i=2 ; i<=N ; ++i) {
    if (vis[i] == false) {
        prime[++cnt] = i;
        minp[i] = i;
    }
    for (int j=1 ; j<=cnt && i * prime[j]<=N; ++j) {
        vis[i * prime[j]] = true;
        minp[i * prime[j]] = prime[j];
        if (i % prime[j] == 0) 
            break;
    }
}
```



记录每个数的最小质数后就可以利用它快速的分解一个数的质因数（ $O(log\ n)$ 的复杂度 ）

```cpp
map<int, int> mp;

while (num != 1){
	mp[minp[num]]++;
	num /= minp[num];
}
```





## gcd和lcm



###  常见算法

对于两数m和n，计算最大公因数常利用辗转相除法，最小公倍数则用算式$m\times n \div gcd(m,n)$计算。更推荐使用库中的 `__gcd() 或 gcd()`  函数，该函数的内部实现经过优化（lcm 同理）。

```cpp
int gcd(int m, int n){
    return n ? m : gcd(n, m%n);
}
int lcm(int m,int n){
    return m*n/gcd(m,n);
}
```

需要注意，对于任意非零数与零的最大公因数，一些作者认为无意义，对于编译器在C++11及以后确认为二者 gcd 即为那个非零的数，或者更形式化的表述 $gcd(0, a) = a, a \neq 0$ 。



### 线性组合

gcd具有线性组合性质，亦称为裴蜀定理

对于任意整数 $a, b$ 存在整数 $x, y$ 使得 $gcd(a, b)\  |\  ax + by$



我们不妨来看一个有趣的例子，对于不等的两个整数 $a，b$
$gcd(a,b)=d_1$
$gcd(a-b,0)=d_2$
不妨写为：$a=d_1 \cdot k_1, \ b=d_1\cdot k_2$
那么有 $d_2 = a-b =d_1\cdot (k_1-k_2)$
$k_1$总是大于$k_2$的，因此有 $gcd(a-b,0) \geq gcd(a,b)$

可见，对于一列不完全相等的数，若能同时加上某一整数，该数列的最大公因数上限为差值的下限


### 相互关系

**四者关系可以从因数分解([素数分解](# 素数分解))的角度来理解。**



对于m和n有：
$$
m = 2^{a_1} \times 3^{a_2} \times 5^{a_3} \times \cdots\cdots \\
n = 2^{b_1} \times 3^{b_2} \times 5^{b_3} \times \cdots\cdots
$$

可注意到：

- gcd必须能同时整除a和b，所以每个素数的指数不能超过a和b中对应素数的最小指数。
- 而lcm需要同时被a和b整除，所以每个素数的指数必须至少等于a和b中的最大指数。



那么对于gcd和lcm有：
$$
gcd = 2^{min(a_1,b_1)} \times 3^{min(a_2,b_2)} \times 5^{min(a_3,b_3)} \times \cdots\\
lcm = 2^{max(a_1,b_1)} \times 3^{max(a_2,b_2)} \times 5^{max(a_3,b_3)} \times \cdots
$$
于是能得到：
$$
m \times n = gcd \times lcm
$$


## 快速幂

$a^b = a^{k_1*2^0}*a^{k_2*2^1}*a^{k_3*2^2}\dots$

$\Rightarrow a^b = a^{k_1*2^0+k_2*2^1+k_3*2^2}\dots$

即将`b`分解成 $k_1*2^0+k_2*2^1+k_3*2^2+k_4*2^3+\dots$

```cpp
//fastPower

#include <iostream>
using namespace std; 

typedef long long ll;

ll fastPower(ll a, ll b) {
    ll res = 1;
    while (b > 0) {
        
        if (b & 1) res *= a; // 如果 b 的当前位是 1，乘以当前的 a
        
        a *= a;				 // 将 a 乘以 a，准备下一次迭代
		b >>= 1;			 // 将 b 右移一位，准备下一位的检查
    }
    return res;
}


int main() {
    ll a;	cin >> a;
    ll b;	cin >> b;
    cout << "Result: " << fastPower(a, b) << endl;
    return 0;
}
```



## 平方和公式

$$
1^2+2^2+3^2+4^2+\dots +n^2 = \frac{n(n+1)(2n+1)}{6}
$$



## 扩展欧几里得算法

扩展欧几里得算法是基于欧几里得算法，求解形如 $ax+by=gcd(a,b)$ 的可行解的方法。

> 当 $gcd(a,b)=1$ 时，问题可转化为逆元的求解。
>
> 即：设x为a在模乘下的逆元，就有$ax\equiv1(mod\ b) \Rightarrow ax+bk=1$

该方法求解过程的核心在于

- $gcd(a,b)=gcd=(b,a\%b)=gcd(b,a-b\lfloor\frac{a}{b}\rfloor)$
- $ax+by = bx' + (a\%b)y'$
- $a\%b=0$ 时，可取$x'=1,y'=0$使得等式成立



于是能得到递推式：

 $ax+by=bx' + (a-b\lfloor\frac{a}{b}\rfloor)y'$

进而：

- $x=y'$
- $y=x'-\lfloor\frac{a}{b}\rfloor y'$



那么便能将 $x'=1,y'=0$ 带入不断的回求x和y。

```cpp
void exgcd(int a,int b, int& x, int & y){
    if(!b) {
        x = 1;
        y = 0;
        
    }else {
        exgcd(b,a%b,x,y);
        int t=x;
        x = y;
        y = t - (a/b)*y;
    }
}
```

****
