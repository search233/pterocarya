# 栈与队列



## 栈

> 栈的修改与访问是按照后进先出的原则进行的，因此栈通常被称为是后进先出（last in first out）表，简称 LIFO 表。 		——oi wiki

对于栈，可以将其理解为一个桶——先放进去的被压在下面，后放进去的在上面。那么先入栈的就只能后出栈后入栈的就能先出栈。



### 栈的实现

C++中提供了`std::stack`用于实现，使用前需引用头文件`<stack>`。

STL 中的 `stack` 容器提供了一众成员函数以供调用，常见的 有三类：

- 访问：
  - `st.top()`：返回栈顶元素的值
- 修改：
  - `st.push()`：将传入的参数推入栈中(栈顶)
  - `st.pop()`：弹出栈顶元素
- 容量：
  - `st.empty()`：检查栈是否为空
  - `st.size()`：返回栈中元素数量

**注意：**

在清空栈时，没有类似其他容器的`clear()`函数，因此常使用循环清空，如：

`while(!st.empty()) st.pop();`



### 单调栈

所谓单调栈，即满足单调性的栈结构。单调栈常用于寻找下一更大/小元素，以及其类似问题。

[单调栈模板题](https://www.luogu.com.cn/problem/P5788)

**题目大意**

对于项数为 n 的数列，$f(i)$ 表示第 i 个元素之后第一个大于 $a_i$ 的元素的下标，求$f(1)-f(n)$。

**解决方案**

```cpp
for(int i=n ; i>=1 ; --i){

	while(!st.empty() && a[i]>=a[st.top()])	s.pop();
    
	res[i]= st.empty() ? 0 : st.top()+1;
    
	st.push(i);	
}
```

简单改一下就能实现记录小于第 i 个元素的数量。

```cpp
for(int i=n-1 ; i>=0 ; --i){
    
	while(!st.empty() && a[i]>=st.top())	st.pop();
	
	ans += st.size();
    
	st.push(a[i]);
}
```



## 队列

> 队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。	——OI wiki



### 队列的实现

CPP中提供了容器`std::queue`，使用前需要引用头文件`<queue>`。

与栈类似，`queue`容器提供了一些函数，常见的有三类函数：

- 访问
  - `qu.frount()`：返回队首元素
  - `qu.back()`：返回队尾元素
- 修改
  - `qu.push()`：在队尾插入元素
  - `qu.pop()`：弹出队首元素
- 容量
  - `qu.empty()`：队列是否为空
  - `qu.size()`：返回队列元素数量



### 优先队列

CPP中优先队列定义如下：

```cpp
std::priority_queue<T, Container, Compare> pq;
```

- T 为队列中元素的类型
- Container 为容器类型，默认为`std::vector<T>`
- Compare 比较函数，默认为 `std::less<T>`(最大元素优先)，可以改为`std::greater<T>`(最小元素优先)。

`std::less<T>` 和 `std::greater<T>` 为定义在 `functional` 中的仿函数，以下给出二者定义的简化版本：

```cpp
template<class T>
struct greater {
    bool operator()(const T& a, const T& b) const {
        return a > b; // 使用类型 T 的 operator>
    }
};

template<class T>
struct less {
    bool operator()(const T& a, const T& b) const {
        return a < b; // 使用类型 T 的 operator<
    }
};
```



