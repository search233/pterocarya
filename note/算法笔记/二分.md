# 二分

## stl的二分查找

> C++ 标准库中实现了查找首个不小于给定值的元素的函数 [`std::lower_bound`](https://zh.cppreference.com/w/cpp/algorithm/lower_bound) 和查找首个大于给定值的元素的函数 [`std::upper_bound`](https://zh.cppreference.com/w/cpp/algorithm/upper_bound)，二者均定义于头文件 `<algorithm>` 中。
>
> 二者均采用二分实现，所以调用前必须保证元素有序。 ——oi wiki



具体实现：

```cpp
lower_bound(arr.begin(), arr.end(), num, greater<int>());
//arr降序排列，返回第一个小于等于num的元素的位置
lower_bound(arr.begin(), arr.end(), num, less<int>());
//arr升序排列，返回第一个大于等于num的元素的位置
upper_bound(arr.begin(), arr.end(), num, greater<int>());
//arr降序排列，返回第一个小于num的元素的位置
upper_bound(arr.begin(), arr.end(), num, less<int>());
//arr升序排列，返回第一个大于num的元素的位置
//comp函数为空时默认为less
```

## 二分答案

> 解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件。把这里的枚举换成二分，就变成了「二分答案」 ——oi wiki



**二分答案本质上是一种枚举**，二分答案的使用需要满足：

1. **单调性：**问题的解空间具有单调性，即随着答案的增大或减小，问题的可行性呈现单调变化。
2. **可判定性：**对于任意给定的答案，能够快速判断其是否满足条件。
3. **答案范围明确：**问题的答案在一个确定的范围内，且范围大小适合二分查找。

其常适用于：

- 最大值最小化或最小值最大化
- 可行性问题
- 搜索问题

## 例题



二分答案关键在于判断函数和查找循环，以[P3853 路标设置 ](https://www.luogu.com.cn/problem/P3853)为例：

**题目大意：**

对于一条长L的公路，原有N个路标，最多能增设P个路标。求增设路标后，两路标间最大距离的最小值。

核心思路：

不断的二分答案，并将答案带入 `judge` 函数中检查正确性，从而在最后定位到那个满足条件的最优答案

主函数：

```cpp
int L, N, K;
int a[100010];

int main(){
	cin >> L >> N >> K;
	for(int i=0 ; i<N ; ++i) cin >> a[i];

	int l=0, r=L, res;

	while(l<=r){
		int mid = (l+r)/2;
		if(judge(mid)){
			res = mid;
			r = mid-1;
		}else l = mid+1;
	}
	
	cout << res;
	
	return 0;
}
```



```cpp
bool judge(int x){
	int pos=0, sum=0;
	for(int i=0 ; i<N ; ++i){
		while(a[i]-pos>x){
			pos += x;
			++sum;
			if(sum>K) return 0;
		}
		
		pos = a[i];
	}
	
	return sum<=K; 
}
```